"""
This script provides the encoding fix functions for the games of Chaos-R.
The encoding of the text content of the games of Chaos-R is Shift-JIS.
In order to run it directly without using Locale Emulator, we need to convert the encoding of the text content from Shift-JIS to UTF-8 (or UTF-16LF).
"""
import os
import shutil


# there are characters that exist in the Shift-JIS encoding but not in the GBK encoding
# this function will help find a full list
def find_shiftjis_not_in_gbk_full():
    """generated by chatgpt, find characters that exist in the Shift-JIS encoding but not in the GBK encoding"""
    start = 0x0000  # Starting from the beginning of Unicode range
    end = 0xFFFF  # Up to the Basic Multilingual Plane
    shiftjis_not_in_gbk = []
    for codepoint in range(start, end):
        character = chr(codepoint)
        try:
            # Try encoding the character in Shift JIS
            sjis_encoded = character.encode("shift_jis")
            try:
                # Try encoding the character in GBK
                gbk_encoded = character.encode("gbk")
            except UnicodeEncodeError:
                # If encoding in GBK fails, add to the list
                shiftjis_not_in_gbk.append(character)
        except UnicodeEncodeError:
            pass

    return shiftjis_not_in_gbk


def fix_encoding(
    input_file_path,
    output_file_path,
    original_encoding="cp932",
    target_encoding="utf_16",
):
    """
    Fix the encoding of the text content of the games of Chaos-R.
    """
    try:
        # Chaos-R games have a file called PageBreak.asd that is encoded in UTF-8
        if os.path.basename(input_file_path) == "PageBreak.asd":
            original_encoding = "utf_8"
            target_encoding = "utf_16"

        with open(input_file_path, "r", encoding=original_encoding) as f:
            content = f.read()

        # Replace characters not supported in GBK if target encoding is GBK
        if target_encoding.lower() == "gbk":
            # get a full list of unsupported characters
            shiftjis_not_in_gbk = find_shiftjis_not_in_gbk_full()
            # map for replacements
            shiftjis_gbk_replacements = {
                "〜": "~",  # Wave Dash to Tilde
                "・": " ",  # Katakana Middle Dot to Period
            }
            # other characters are replaced with a space
            for char in shiftjis_not_in_gbk:
                if char not in shiftjis_gbk_replacements:
                    shiftjis_gbk_replacements[char] = " "

            for orig_char, replacement in shiftjis_gbk_replacements.items():
                content = content.replace(orig_char, replacement)

    except UnicodeDecodeError:
        print(f"UnicodeDecodeError: {input_file_path}")
        try:
            open(input_file_path, "r", encoding=target_encoding)
            print(f"Already converted: {input_file_path}")
            shutil.copyfile(input_file_path, output_file_path)
            return True
        except UnicodeDecodeError:
            return False

    with open(output_file_path, "w", encoding=target_encoding) as f:
        f.write(content)

    return True


def fix_allfiles(
    scriptfile_list, replace=False, original_encoding="cp932", target_encoding="utf_8"
):
    """fix all files of a game instance"""
    # get all files with the given extensions

    # fix the encoding of these files
    for scriptfile in scriptfile_list:
        file = scriptfile.script_file_path
        # print status
        print(
            f"Fixing encoding of {scriptfile.script_file_path}, {scriptfile_list.index(scriptfile) + 1}/{len(scriptfile_list)}"
        )
        # create the output file path
        output_file = file + "new_encoding"
        # fix the encoding
        fix_encoding(
            input_file_path=file,
            output_file_path=output_file,
            original_encoding=original_encoding,
            target_encoding=target_encoding,
        )
        if replace:
            # delete the original file
            os.remove(file)
            # rename the new file
            os.rename(output_file, file)

    return
